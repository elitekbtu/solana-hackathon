    
### Aegis Engine: Anchor Smart Contract Rules (@anchor)

Этот документ определяет правила и соглашения для разработки смарт-контракта на Anchor. Все генерируемые и написанные вручную фрагменты кода на Rust и TypeScript (тесты) ДОЛЖНЫ соответствовать этим правилам.

---

### 1. Guiding Principles (KISS, DRY, SOLID)

-   **KISS (Keep It Simple, Stupid):** Одна инструкция — одна логическая операция. Не пытайся уместить минт, апдейт и сжигание в одной функции.
-   **DRY (Don't Repeat Yourself):** Вспомогательные функции Rust выноси в отдельный модуль. В тестах на TypeScript создавай helper-функции для повторяющихся действий (например, `createAndMintToken`).
-   **SOLID (Single Responsibility):**
    -   **Инструкция** отвечает только за свою бизнес-логику.
    -   **Структура аккаунтов (`#[derive(Accounts)]`)** отвечает только за **ВАЛИДАЦИЮ** и проверку безопасности входящих аккаунтов.

---

### 2. MUST HAVE: Rust Program (`programs/aegis_engine/src/lib.rs`)

#### **a. Структура и Нейминг**

-   **Порядок в файле:**
    1.  `use` стейтменты.
    2.  `declare_id!`.
    3.  `#[program] mod ...`.
    4.  Структуры аккаунтов (`#[derive(Accounts)]`).
    5.  Кастомные структуры (`#[account]`).
    6.  Кастомные ошибки (`#[error_code]`).
-   **Нейминг:**
    -   Функции инструкций: `snake_case` (например, `mint_nft`).
    -   Структуры аккаунтов: `PascalCase`, с суффиксом `'info` и названием, соответствующим инструкции (например, `MintNft<'info>`).

#### **b. Безопасность и Валидация Аккаунтов (САМОЕ ВАЖНОЕ)**

-   **НИКОГДА** не доверяй аккаунтам, переданным с клиента. **ВСЕГДА** используй constraints от Anchor для их проверки.
-   **`init`:** Используй для создания нового аккаунта. **ВСЕГДА** указывай `payer`, `space` (размер) и другие необходимые параметры.
-   **`mut`:** Используй **ТОЛЬКО** для тех аккаунтов, которые ты действительно собираешься изменять. Это защищает от случайных записей.
-   **`has_one = <authority_field>`:** **ВСЕГДА** используй для проверки, что переданный `Signer` (подписавший транзакцию) является владельцем аккаунта, с которым производится операция.
-   **`seeds = [...]` и `bump`:** **ВСЕГДА** используй для валидации Program Derived Addresses (PDA). Никогда не доверяй PDA, переданному с клиента, без проверки `seeds`.
-   **`/// CHECK: ...`:** Используй этот комментарий **ТОЛЬКО** в крайнем случае, когда Anchor не может проверить тип аккаунта (например, программы типа `token_metadata_program`). **ВСЕГДА** оставляй после `CHECK:` объяснение, почему это безопасно.

#### **c. Логика и Ошибки**

-   **Логирование:** Используй `msg!("...")` для отладки, чтобы видеть шаги выполнения и значения переменных в логах транзакции.
-   **Ошибки:** **ВСЕГДА** создавай кастомный `enum` для ошибок с атрибутом `#[error_code]`. Используй `require!` для проверок внутри инструкций, чтобы возвращать понятные ошибки вместо паники.

```rust
// Хороший пример ошибки
#[error_code]
pub enum AegisError {
    #[msg("Not enough mana to mint this item.")]
    NotEnoughMana,
}
// require!(player.mana >= 100, AegisError::NotEnoughMana);

  

3. MUST HAVE: TypeScript Tests (tests/*.ts)
a. Структура Теста

    Используй describe для группировки тестов и it для каждого отдельного кейса.

    Setup: В начале теста инициализируй provider, program, payer и Metaplex SDK.

    Логирование: ВСЕГДА выводи в консоль ключевые адреса (mint.publicKey.toBase58()) и сигнатуру транзакции (txSignature). Это ускоряет отладку в 10 раз.

b. Подготовка и Вызов

    Не хардкодь адреса: Используй Keypair.generate() для новых аккаунтов. Используй PDA-функции из Metaplex SDK (metaplex.nfts().pdas().metadata(...)) для вычисления адресов.

    Полный цикл: Тест должен не только отправлять транзакцию, но и проверять результат.

    Проверка (Assertion): ВСЕГДА делай fetch созданных или измененных аккаунтов после выполнения транзакции и проверяй их поля с помощью assert. Тест без проверки — это не тест.

code TypeScript
IGNORE_WHEN_COPYING_START
IGNORE_WHEN_COPYING_END

    
// Хороший пример проверки
const createdNft = await metaplex.nfts().findByMint({ mintAddress: mint.publicKey });
assert.equal(createdNft.name, nftTitle, "NFT name should match");
assert.equal(createdNft.uri, nftUri, "NFT URI should match");

  

4. Example Prompts for AI

    Плохо: "напиши контракт для минта"

    Хорошо: "Используя @anchor/cursor.rules, создай инструкцию mint_item. Она должна принимать title, symbol, uri. Создай структуру аккаунтов MintItem, которая инициализирует mint, associated_token_account, metadata_account и master_edition_account, используя Metaplex. payer должен быть Signer и платить за создание всех аккаунтов."

    Хорошо: "Напиши тест для инструкции mint_item. Он должен сгенерировать новый mint Keypair, вычислить все необходимые PDA с помощью Metaplex SDK, вызвать инструкцию и затем, используя metaplex.nfts().findByMint, проверить, что имя и URI созданного NFT соответствуют переданным в инструкцию."